# Домашнее задание 1

## Задание 1
Продолжим работать с нашим приложением для автогонок.

Создайте список всех автомобилей, которые участвуют в автогонке. По нашей логике в гонках участвуют объекты всех классов: «Легковые автомобили», «Грузовые автомобили» и «Автобусы».

У каждого автомобиля есть список спонсоров и водителей.

Напомним, что водитель может управлять только одним автомобилем в гонках и больше никаким.

Один спонсор может поддерживать несколько автомобилей. Спонсором может быть как компания, так и физическое лицо. В качестве параметров спонсор содержит имя (или название), а также сумму поддержки. У спонсоров есть метод «спонсировать заезд».

Кроме того, каждый автомобиль проходит техобслуживание, поэтому у него есть команда механиков.

Создайте новый класс механик с параметрами:

имя и фамилия;
компания, в которой он работает;
с какими автомобилями может работать (например, только с легковыми, грузовыми авто, автобусами или со всеми).
Методы:

«провести техобслуживание»,
«починить машину».
Количество механиков, которые могут работать над одной машиной, установите самостоятельно. Один механик может работать с несколькими машинами.

Напишите программу, с помощью которой можно узнать, как зовут водителя авто, какие спонсоры и механики у нее есть.

Критерии оценки
- Создан список всех автомобилей с помощью List.
- Создан новый спонсор с набором параметров и методов.
- Создан список спонсоров с помощью List.
- Создан список водителей с помощью List.
- Создан новый класс механик с набором параметров и методов.
- Методы класса предопределены для объектов.
- Настроены модификаторы доступа.
- Созданы геттеры и сеттеры.
- Создан список механиков с помощью List.

#  Домашнее задание 2

## Задание 1
Добавьте новый класс «Станция техобслуживания», в которой реализована очередь из авто. Кроме этого, в классе есть методы «добавить авто в очередь» и «провести техосмотр авто».

Напомним, что автобусы не нуждаются в техобслуживании перед заездом, поэтому они в очередь не встают.

Каждый новый объект становится в конец очереди на техобслуживание. Как только машина проходит техобслуживание, она должна из очереди удаляться.

Критерии оценки
- Создан новый класс «Станция техобслуживания» и методы «добавить авто в очередь» и «провести техосмотр авто».
- Настроены модификаторы доступа.
- Создана очередь из авто с помощью queue.


## Задание 2
Подходя к кассе супермаркета, мы выбираем очередь, в которой меньше всего людей. Когда становится слишком много людей, один из сотрудников вызывает Галю, открывающую дополнительную кассу.

Напишите программу, в которой имитируется данное поведение.

Создайте 2 очереди (Queue<String>) с максимальной размерностью 5. Заполните обе очереди случайным количеством элементов (от 0 до 5 — для каждой очереди свой случайный элемент). В качестве значения используйте имя человека в этой очереди (можно использовать любую строку/строки).

Напишите новый метод, принимающий строку (имя человека), который добавляет человека в очередь, где меньше всего людей. Если обе очереди заполнены, выведите в консоль просьбу позвать Галю.

Дополнительное условие со звездочкой
(необязательно к решению)
Напишите еще один метод, при вызове которого удаляется человек из случайной очереди.

Критерии оценки
- Выбрана реализация очереди с возможностью ограничить максимальное количество элементов.
- Начальное заполнение элементов в 2 очередях выполняется согласно условиям задачи.
- Новый человек добавляется в очередь с наименьшим количеством элементов.
- При полном заполнении двух очередей информация об этом выводится на экран (*или создается еще одна очередь).
- Программа не падает с ошибкой.
- При удалении элемента очередь выбирается случайно.


## Задание 3
В данном задании мы попрактикуемся в работе с вложенным (двумерным) списком. Двумерный список можно объявить таким способом:

List<List<Int>> biDemArrList = new ArrayList<>();
В данном случае мы получим матрицу, содержащую целые числа. Чтобы достать нужное нам число, нужно написать следующий код:

int ourNumber = biDemArrList.get(0).get(1)
Где 0 — индекс элемента по вертикали, 1 — индекс по вертикали.

Ваше задание: необходимо сделать 2 доработки в коде, вывести в консоль шахматную доску.

Исходные данные:

void example() {
List> biDemArrList = new ArrayList<>();
for (int i = 0; i < 8; i++) {
biDemArrList.add(i, new ArrayList<>());
for (int j = 0; j < 8; j++) {
biDemArrList.get(i).add(j, "◯");
}
}
for (int i = 0; i < 8; i++) {
for (int j = 0; j < 8; j++) {
System.out.print(biDemArrList.get(i).get(j) + " ");
}
}
}
Первый этап: дополнить цикл с выводом таким образом, чтобы на выходе программа стала выводить в консоль шахматную доску со всеми белыми клетками (перенос строк после каждого 8-го элемента):

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯

◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯
Второй этап: изменить заполнение двумерного списка, добавив символ ● (черная клетка) так, чтобы вывод кружков стал в шахматном порядке:

◯ ● ◯ ● ◯ ● ◯ ●

● ◯ ● ◯ ● ◯ ● ◯

◯ ● ◯ ● ◯ ● ◯ ●

● ◯ ● ◯ ● ◯ ● ◯

◯ ● ◯ ● ◯ ● ◯ ●

● ◯ ● ◯ ● ◯ ● ◯

◯ ● ◯ ● ◯ ● ◯ ●

● ◯ ● ◯ ● ◯ ● ◯


Критерии оценки
В консоль кружки выводятся в шахматном порядке: черный-белый.
Создание переменной biDemArrList не было изменено.
Подсказки
System.out.print() используемая в примере, не добавляет перенос строки после вывода. Чтобы сделать перенос строки, используйте метод System.out.println().
Если сумма индексов (i + j) нечетная, то клетка — черная.